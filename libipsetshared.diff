diff --git a/include/libipset/Makefile.am b/include/libipset/Makefile.am
index 79a1357..dcade7d 100644
--- a/include/libipset/Makefile.am
+++ b/include/libipset/Makefile.am
@@ -3,6 +3,7 @@ pkginclude_HEADERS = \
 	args.h \
 	data.h \
 	errcode.h \
+	ipset_lib.h \
 	linux_ip_set_bitmap.h \
 	linux_ip_set.h \
 	linux_ip_set_hash.h \
diff --git a/include/libipset/ipset_lib.h b/include/libipset/ipset_lib.h
new file mode 100644
index 0000000..b5f5c16
--- /dev/null
+++ b/include/libipset/ipset_lib.h
@@ -0,0 +1,23 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef LIBIPSET_SHLIB_H
+#define LIBIPSET_SHLIB_H
+
+int  ipset_init_lib(void);
+void ipset_close_lib(void);
+int  ipset_session_reset(void);
+int  ipset_session_restart(void);
+int  ipset_session_commit(void);
+void ipset_session_flush_report(void);
+void ipset_session_fdclose(void);
+void *ipset_load_type(const char *s_type);
+int  ipset_check(char *s_type,char *setname,char *ip);
+int  ipset_exist(char *setname,char *buf,size_t len);
+int  ipset_parse_file(struct ipset_session *s , int opt, const char *str);
+int  ipset_parse_commandline(int argc, char *argv[]);
+int  parse_commandline(int argc, char *argv[]); /* for compatible with old version */
+
+#endif	/* LIBIPSET_UTILS_H */
diff --git a/include/libipset/session.h b/include/libipset/session.h
index bac4d19..4735371 100644
--- a/include/libipset/session.h
+++ b/include/libipset/session.h
@@ -82,6 +82,9 @@ enum ipset_envopt {
 
 extern int ipset_envopt_parse(struct ipset_session *session,
 			      int env, const char *str);
+extern void
+ipset_envopt_reset(struct ipset_session *session);
+
 extern bool ipset_envopt_test(struct ipset_session *session,
 			      enum ipset_envopt env);
 
@@ -105,6 +108,7 @@ typedef int (*ipset_outfn)(const char *fmt, ...)
 extern int ipset_session_outfn(struct ipset_session *session,
 			       ipset_outfn outfn);
 extern struct ipset_session *ipset_session_init(ipset_outfn outfn);
+extern void ipset_session_reinit(struct ipset_session *session);
 extern int ipset_session_fini(struct ipset_session *session);
 
 extern void ipset_debug_msg(const char *dir, void *buffer, int len);
diff --git a/lib/libipset.map b/lib/libipset.map
index 475fae5..727f1ec 100644
--- a/lib/libipset.map
+++ b/lib/libipset.map
@@ -87,11 +87,13 @@ global:
   ipset_session_error;
   ipset_session_warning;
   ipset_envopt_parse;
+  ipset_envopt_reset;
   ipset_envopt_test;
   ipset_session_output;
   ipset_commit;
   ipset_cmd;
   ipset_session_init;
+  ipset_session_reinit;
   ipset_session_fini;
   ipset_debug_msg;
   ipset_cache_add;
diff --git a/lib/session.c b/lib/session.c
index ca96aaa..62331f1 100644
--- a/lib/session.c
+++ b/lib/session.c
@@ -149,6 +149,17 @@ ipset_envopt_parse(struct ipset_session *session, int opt,
 	}
 	return -1;
 }
+/**
+ * ipset_envopt_rest - clean environment option
+ * @session: session structure
+ */
+
+void
+ipset_envopt_reset(struct ipset_session *session)
+{
+	assert(session);
+	session->envopts = 0;
+}
 
 /**
  * ipset_envopt_test - test environment option
@@ -2083,6 +2094,24 @@ free_session:
 	return NULL;
 }
 
+void
+ipset_session_reinit(struct ipset_session *session)
+{
+	assert(session);
+
+	ipset_session_report_reset(session);
+	ipset_cache_fini();
+
+	if (session->data)
+		ipset_data_reset(ipset_session_data(session));
+
+	ipset_cache_init();
+	session->cmd = IPSET_CMD_NONE;
+	if(session->buffer && session->bufsize)
+		memset(session->buffer,0,session->bufsize);
+}
+
+
 /**
  * ipset_session_fini - destroy an ipset session
  * @session: session structure
diff --git a/src/Makefile.am b/src/Makefile.am
index 810efb7..d562bab 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -2,6 +2,7 @@ include $(top_srcdir)/Make_global.am
 
 sbin_PROGRAMS	= ipset
 ipset_SOURCES	= ipset.c ui.c
+ipset_CFLAGS	= -DIPSET_MAIN
 ipset_LDADD	= ../lib/libipset.la
 
 if ENABLE_SETTYPE_MODULES
@@ -14,6 +15,13 @@ endif
 
 dist_man_MANS = ipset.8
 
+lib_LTLIBRARIES                = libipsetshared.la
+libipsetshared_la_SOURCES      = ipset.c \
+                                 ui.c
+libipsetshared_la_CFLAGS       = -DIPSET_SO_LIB
+libipsetshared_la_LIBADD       = ../lib/libipset.la
+libipsetshared_la_LDFLAGS      = -version-number 0:6:380
+
 sparse-check: $(ipset_SOURCES:.c=.d)
 
 %.d: %.c
diff --git a/src/ipset.c b/src/ipset.c
index ce1b73f..14c5857 100644
--- a/src/ipset.c
+++ b/src/ipset.c
@@ -25,12 +25,20 @@
 #include <libipset/ui.h>		/* core options, commands */
 #include <libipset/utils.h>		/* STREQ */
 
+#ifndef IPSET_SO_LIB
+/* Main parser function, workhorse */
+int ipset_parse_commandline(int argc, char *argv[]);
+#else
+#include <libipset/ipset_lib.h>
+#endif
+
 static char program_name[] = PACKAGE;
 static char program_version[] = PACKAGE_VERSION;
 
 static struct ipset_session *session;
 static uint32_t restore_line;
 static bool interactive;
+static bool quietmode=false;
 static char cmdline[1024];
 static char *newargv[255];
 static int newargc;
@@ -50,7 +58,7 @@ exit_error(int status, const char *msg, ...)
 {
 	bool quiet = !interactive &&
 		     session &&
-		     ipset_envopt_test(session, IPSET_ENV_QUIET);
+		     ipset_envopt_test(session, IPSET_ENV_QUIET) || quietmode;
 
 	if (status && msg && !quiet) {
 		va_list args;
@@ -89,7 +97,7 @@ static int
 handle_error(void)
 {
 	if (ipset_session_warning(session) &&
-	    !ipset_envopt_test(session, IPSET_ENV_QUIET))
+	    !ipset_envopt_test(session, IPSET_ENV_QUIET) && !quietmode)
 		fprintf(stderr, "Warning: %s\n",
 			ipset_session_warning(session));
 	if (ipset_session_error(session))
@@ -212,9 +220,6 @@ build_argv(char *buffer)
 	free(arg);
 }
 
-/* Main parser function, workhorse */
-int parse_commandline(int argc, char *argv[]);
-
 /*
  * Performs a restore from stdin
  */
@@ -256,7 +261,7 @@ restore(char *argv0)
 		build_argv(c);
 
 		/* Execute line */
-		ret = parse_commandline(newargc, newargv);
+		ret = ipset_parse_commandline(newargc, newargv);
 		if (ret < 0)
 			handle_error();
 	}
@@ -541,7 +546,7 @@ static const char *cmd_prefix[] = {
 
 /* Workhorse */
 int
-parse_commandline(int argc, char *argv[])
+ipset_parse_commandline(int argc, char *argv[])
 {
 	int ret = 0;
 	enum ipset_cmd cmd = IPSET_CMD_NONE;
@@ -674,7 +679,7 @@ parse_commandline(int argc, char *argv[])
 				/* Build fake argv, argc */
 				build_argv(c);
 				/* Execute line: ignore soft errors */
-				if (parse_commandline(newargc, newargv) < 0)
+				if (ipset_parse_commandline(newargc, newargv) < 0)
 					handle_error();
 				printf("%s> ", program_name);
 			}
@@ -879,6 +884,7 @@ parse_commandline(int argc, char *argv[])
 	return ret;
 }
 
+#ifndef IPSET_SO_LIB
 int
 main(int argc, char *argv[])
 {
@@ -893,7 +899,7 @@ main(int argc, char *argv[])
 		return exit_error(OTHER_PROBLEM,
 			"Cannot initialize ipset session, aborting.");
 
-	ret = parse_commandline(argc, argv);
+	ret = ipset_parse_commandline(argc, argv);
 
 	ipset_session_fini(session);
 	if (fd)
@@ -901,3 +907,104 @@ main(int argc, char *argv[])
 
 	return ret;
 }
+#else
+
+int ipset_init_lib(void) {
+
+	interactive = true;
+	quietmode = true;
+
+	/* Load set types */
+	ipset_load_types();
+
+	return ipset_session_reset();
+}
+
+void ipset_close_lib(void)
+{
+       ipset_session_fini(session);
+}
+
+int ipset_session_reset(void) {
+
+	if(session) ipset_session_fini(session);
+	session = ipset_session_init(printf);
+	if (session == NULL)
+		return exit_error(OTHER_PROBLEM,
+			"Cannot initialize ipset session, aborting.");
+	ipset_envopt_parse(session,IPSET_ENV_QUIET,"");
+	return 0;
+}
+
+int ipset_session_commit(void) {
+	return session ? ipset_commit(session) : -1;
+}
+
+void ipset_session_flush_report(void) {
+	ipset_session_report_reset(session);
+}
+
+void ipset_session_fdclose(void) {
+	if(fd) {
+		fclose(fd);
+		fd = NULL;
+	}
+	filename = NULL;
+}
+
+void *ipset_load_type(const char *name) {
+        return (void *)type_find(name);
+}
+
+int ipset_check(char *s_type,char *setname,char *ip) {
+	char *arg[8],*sn,*sa;
+	int ret;
+
+	if(s_type && *s_type && !type_find(s_type)) return -1;
+
+	arg[0]="ipset";
+	arg[1]="test";
+	sn = arg[2] = strdup(setname);
+	sa = arg[3] = strdup(ip);
+	arg[4] = NULL;
+	ret =  arg[2] &&  arg[3] ? ipset_parse_commandline(4, arg): -1;
+	if(sn) free(sn);
+	if(sa) free(sa);
+	return ret;
+}
+
+int ipset_exist(char *setname,char *buf,size_t bufsize) {
+	char *arg[8];
+	int ret;
+
+	ipset_session_reinit(session);
+	ipset_envopt_reset(session);
+	ipset_envopt_parse(session,IPSET_ENV_QUIET,"");
+
+	ret = ipset_parse_setname(session, IPSET_SETNAME, setname);
+	if(ret >= 0)
+		ret = ipset_cmd(session, IPSET_CMD_HEADER , restore_line);
+	if(ret >= 0 && buf && bufsize) {
+		const char *sn = ipset_data_get(ipset_session_data(session),IPSET_OPT_TYPENAME);
+		strncpy(buf,sn ? sn : "",bufsize);
+	} else {
+		if(buf) *buf = 0;
+	}
+	ipset_session_reinit(session);
+	ipset_envopt_reset(session);
+	ipset_envopt_parse(session,IPSET_ENV_QUIET,"");
+
+	return ret == 0;
+}
+
+int ipset_session_restart(void) {
+	if(session) ipset_session_reinit(session);
+	return session ? 0 : -1;
+}
+
+int parse_commandline(int argc, char *argv[]) {
+	return ipset_parse_commandline(argc, argv);
+}
+
+#endif
+
